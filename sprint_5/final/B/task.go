package main

/*
--- ID посылки:
69215872

--- Принцип работы:
На вход нам подаеся корень двоичного дерева и мы рекурсией начинам поиск по нему в поисках нужной ноды.
Если текущая нода не подходит, и ее значение больше, чем данный нам ключ, то ищем в левом поддереве, если меньше - то в правом.
В результате вернется измененная (или не измененная) левое или правое поддерево, в зависимости от того, в какое поддерево мы пошли.
Если мы нашли нужную нам ноду, то у нас три варианта того что произойдет:
- нужная нам нода оказалась листом. В данном случае мы просто возвращаем nil тем самым удаляя ноду
- нужная нам нода имеет только одно поддерево. В данном случае мы просто возвращаем поддерево, тем самым удаляя ноду
- нужная нам нода оказалась полноценным родителем. В данном случае я выбрал поиск наименьшего значения в правом поддереве
Поиск наименьшего значения работает почти также как и основанная функция, за исключением того,
что она идет только влево и возвращает нам значение удаленной ноды

--- Временная сложность:
Сложность всегда составляет O(h) где h - высота дерева:
 - искомый ключ находится в листе, то нужно преодолеть h нод чтобы до него добраться.
 - искомый ключ находится где-то в начале или середине то чтобы найти потребуется, конечно,
меньше времени (O(1) если в начале, O(h / 2) если в середине) но чтобы найти наименьший элемент потребуется все оставшееся время.
Но, если дерево сбалансированно, то удаление будет занимать O(log n)

--- Пространственная сложность:
O(1), тк мы дополнительно не создаем ничего, а используем то что есть.
*/

// Node структура узла
// TODO закомментить перед отправкой (если компилятор Make)
type Node struct {
	value int
	left  *Node
	right *Node
}

// remove удаление узла
func remove(node *Node, key int) *Node {
	// не знаю, по мне с рекурсией больше импонирует метод)
	// конечно, на больших глубинах рекурсия может мне аукнется и станет дорогим удовольствием.
	// реализовал на итерации, без рекурсии
	if node == nil {
		return nil
	}

	var currNode = node
	var prevNode *Node

	// присутствует ли ключ в BST
	for currNode != nil && currNode.value != key {
		prevNode = currNode
		if currNode.value < key {
			currNode = currNode.right
		} else {
			currNode = currNode.left
		}
	}
	if currNode == nil {
		return node
	}

	// если есть зотя бы один узел
	if currNode.left == nil || currNode.right == nil {
		var newNode *Node // новый узел

		if currNode.left == nil {
			newNode = currNode.right
		} else {
			newNode = currNode.left
		}

		if prevNode == nil {
			return newNode
		}

		if currNode == prevNode.left {
			prevNode.left = newNode
		} else {
			prevNode.right = newNode
		}

		currNode = nil
	} else {
		var parent, tmp *Node

		tmp = currNode.right
		for tmp.left != nil {
			parent = tmp
			tmp = tmp.left
		}

		if parent != nil {
			parent.left = tmp.right
		} else {
			currNode.right = tmp.right
		}

		currNode.value = tmp.value
		tmp = nil
	}

	return node
}

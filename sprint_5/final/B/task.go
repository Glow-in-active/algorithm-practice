package main

/*
--- ID посылки:
69143502

--- Принцип работы:
На вход нам подаеся корень двоичного дерева и мы рекурсией начинам поиск по нему в поисках нужной ноды.
Если текущая нода не подходит, и ее значение больше, чем данный нам ключ, то ищем в левом поддереве, если меньше - то в правом.
В результате вернется измененная (или не измененная) левое или правое поддерево, в зависимости от того, в какое поддерево мы пошли.

Если мы нашли нужную нам ноду, то у нас три варианта того что произойдет:
- нужная нам нода оказалась листом. В данном случае мы просто возвращаем nil тем самым удаляя ноду
- нужная нам нода имеет только одно поддерево. В данном случае мы просто возвращаем поддерево, тем самым удаляя ноду
- нужная нам нода оказалась полноценным родителем. В данном случае я выбрал поиск наименьшего значения в правом поддереве

Поиск наименьшего значения работает почти также как и основанная функция, за исключением того,
что она идет только влево и возвращает нам значение удаленной ноды

--- Временная сложность:
Сложность всегда составляет O(h) где h - высота дерева:
 - искомый ключ находится в листе, то нужно преодолеть h нод чтобы до него добраться.
 - искомый ключ находится где-то в начале или середине то чтобы найти потребуется, конечно,
меньше времени (O(1) если в начале, O(h / 2) если в середине) но чтобы найти наименьший элемент потребуется все оставшееся время.
Но, если дерево сбалансированно, то удаление будет занимать O(log n)

--- Пространственная сложность:
O(1), тк мы дополнительно не создаем ничего, а используем то что есть.
*/

// Node структура узла
// TODO закомментить перед отправкой (если компилятор Make)
type Node struct {
	value int
	left  *Node
	right *Node
}

// remove удаление узла
func remove(node *Node, key int) *Node {
	if node == nil {
		return node
	}

	if node.value == key {
		if node.left == nil && node.right == nil {
			return nil
		}

		if node.left == nil {
			return node.right
		}

		if node.right == nil {
			return node.left
		}

		value, replaceNode := findAndDeleteInTree(node.right)
		node.right = replaceNode
		node.value = value

		return node
	}

	if node.value > key {
		newNode := remove(node.left, key)
		node.left = newNode
	} else {
		newNode := remove(node.right, key)
		node.right = newNode
	}

	return node
}

// findAndDeleteInTree
// если есть и правое и левое поддерево, то ищем в правой самое маленькое значение
// попутно удаляя его и ставя на место правого поддерева новое значение
func findAndDeleteInTree(n *Node) (int, *Node) {
	if n.left == nil {
		if n.right == nil {
			return n.value, nil
		}
		return n.value, n.left
	}

	value, replaceNode := findAndDeleteInTree(n.left)
	n.left = replaceNode

	return value, n
}

package main

/*
--- ID посылки:
69193344

--- Принцип работы:
На вход нам подаеся корень двоичного дерева и мы рекурсией начинам поиск по нему в поисках нужной ноды.
Если текущая нода не подходит, и ее значение больше, чем данный нам ключ, то ищем в левом поддереве, если меньше - то в правом.
В результате вернется измененная (или не измененная) левое или правое поддерево, в зависимости от того, в какое поддерево мы пошли.
Если мы нашли нужную нам ноду, то у нас три варианта того что произойдет:
- нужная нам нода оказалась листом. В данном случае мы просто возвращаем nil тем самым удаляя ноду
- нужная нам нода имеет только одно поддерево. В данном случае мы просто возвращаем поддерево, тем самым удаляя ноду
- нужная нам нода оказалась полноценным родителем. В данном случае я выбрал поиск наименьшего значения в правом поддереве
Поиск наименьшего значения работает почти также как и основанная функция, за исключением того,
что она идет только влево и возвращает нам значение удаленной ноды

--- Временная сложность:
Сложность всегда составляет O(h) где h - высота дерева:
 - искомый ключ находится в листе, то нужно преодолеть h нод чтобы до него добраться.
 - искомый ключ находится где-то в начале или середине то чтобы найти потребуется, конечно,
меньше времени (O(1) если в начале, O(h / 2) если в середине) но чтобы найти наименьший элемент потребуется все оставшееся время.
Но, если дерево сбалансированно, то удаление будет занимать O(log n)

--- Пространственная сложность:
Поскольку мы работаем только со ссылками на узлы дерева, то выделяется О(1) пямяти для их хранения,
которые необходимо удалить, а также на родителя удаляемого узла. Так как происходят рекурсивные вызовы, то для хранения вызовов в стеке
потребуется О(H) памяти, где H - высота дерева.
*/

// Node структура узла
// TODO закомментить перед отправкой (если компилятор Make)
type Node struct {
	value int
	left  *Node
	right *Node
}

// remove удаление узла
func remove(node *Node, key int) *Node {
	if node == nil {
		return node
	}

	if node.value > key {
		node.left = remove(node.left, key)

	} else if node.value < key {
		node.right = remove(node.right, key)

	} else {
		if node.left == nil {
			return node.right
		} else if node.right == nil {
			return node.left
		}

		// обходим циклом, исключая доп рекурсию
		prev := node
		newNode := node.right

		for newNode.left != nil {
			prev = newNode
			newNode = newNode.left
		}

		if prev == node {
			newNode.left = prev.left
			return newNode
		}

		prev.left = nil
		newNode.left = node.left
		newNode.right = node.right

		return newNode
		//minNode := checkAndDeleteInTree(node.right)
		//node.value = minNode.value
		//node.right = remove(node.right, minNode.value)
	}

	return node
}

// checkAndDeleteInTree
//func checkAndDeleteInTree(root *Node) *Node {
//	for nil != root && root.left != nil {
//		root = root.left
//	}
//	return root
//}
